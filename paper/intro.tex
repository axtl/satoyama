\section{\label{sec:intro}Introduction}

Web applications have grown to be one of the most popular types of software in use today. The World Wide Web provides a platform that is accessible to users regardless of geographic location or operating system, which were previously some of the main issues affecting the distribution and proliferation of software. Instead, web applications afford rapid development cycles and low economic risks, and are immediately accessible to interested users. There is a significantly lower barrier to adoption as well, as no software must be downloaded, trusted to be free of viruses, or installed by users. Even in situations were native applications are subsequently developed, the availability of a web version is still desirable as it serves both as a hub of activity for the user, and as a way to ensure data is accessible from anywhere, at anytime.

In situations where web developers want to open their service to other applications --- either to spur the growth of a third-party ecosystem, or simply to build multiple native applications for it --- the question of \emph{how} communication should be accomplished is raised. For those developing client applications for a service that they control, it may seem sufficient to come up with a proprietary, custom-built protocol. But the complexity of maintaining such a loosely-defined protocol, especially if multiple applications must use it, would negatively impact developer resources and application quality. It is within the spirit of sane software engineering practice that such a protocol would be designed as an Application Programming Interface (API), and would thus enable components to communicate with one another in a documented and predefined manner. Whether this API is opened to third-party developers or not is not important, as such a decision may be more likely influenced by market forces rather than software engineering considerations.

The prevalence of rich web applications has propelled JavaScript (formally, ECMAScript~\cite{ecmascriptiso}) into the top positions of various programming language indexes~\cite{ghstats}\cite{tlpi}\cite{tiobe}. Even if the methods for collecting data for these indexes may be lacking scientific rigour they do reflect current trends in the industry. In general, it is empirically observable that websites providing rich experiences use JavaScript to do so. It stands to reason that an increasing number of developers are skilled with the language, and with the advent of server-side JavaScript frameworks, the language can be used universally for web applications, for both front- and back-end.

This paper sets out to analyze how an end-to-end JavaScript application compares to a more traditional design. It will briefly look at the steps taken to design an API for such an application, and then compare the two architectures. Section~\ref{sec:relwork} looks at related work. Section~\ref{sec:arch} provides details on the two architectures used for testing, especially the design. Section~\ref{sec:impl} provides details on the implementations, while section~\ref{sec:eval} evaluates them. Section~\ref{sec:fw} looks at possible avenues for improvement, while section~\ref{sec:con} concludes.