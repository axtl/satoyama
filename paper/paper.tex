\documentclass[letterpaper,twocolumn,10pt,draft]{article}
\usepackage{style}
\usepackage{booktabs}
\begin{document}

%don't want date printed
\date{}

%make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\fontfamily{phv}\selectfont
    {\huge{\textbf{Satoyama}}}\\
    {\large{\textbf{\\An Analysis of End-to-End JavaScript Applications}}}}


%for single author (just remove % characters)
\author{
{\rm \textbf{Alexandru Totolici}}\\
{\rm totolici@cs.ubc.ca}\\
Computer Science Department\\
University of British Columbia\\
} % end author

\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}

\begin{abstract}
\end{abstract}

\section{\label{sec:intro}Introduction}

Web applications have grown to be one of the most popular types of software in use today. The World Wide Web provides a platform that is accessible to users regardless of geographic location or operating system, which were previously some of the main issues affecting the distribution and proliferation of software. Instead, web applications afford rapid development cycles and low economic risks, and are immediately accessible to interested users. There is a significantly lower barrier to adoption as well, as no software must be downloaded, trusted to be free of viruses, or installed by users. Even in situations were native applications are subsequently developed, the availability of a web version is still desirable as it serves both as a hub of activity for the user, and as a way to ensure data is accessible from anywhere, at anytime.

In situations where web developers want to open their service to other applications --- either to spur the growth of a third-party ecosystem, or simply to build multiple native applications for it --- the question of \emph{how} communication should be accomplished is raised. For those developing client applications for a service that they control, it may seem sufficient to come up with a proprietary, custom-built protocol. But the complexity of maintaining such a loosely-defined protocol, especially if multiple applications must use it, would negatively impact developer resources and application quality. It is within the spirit of sane software engineering practice that such a protocol would be designed as an Application Programming Interface (API), and would thus enable components to communicate with one another in a documented and predefined manner. Whether this API is opened to third-party developers or not is not important, as such a decision may be more likely influenced by market forces rather than software engineering considerations.

The prevalence of rich web applications has propelled JavaScript (formally, ECMAScript~\cite{ecmascriptiso}) into the top positions of various programming language indexes~\cite{ghstats}\cite{tlpi}\cite{tiobe}. Even if the methods for collecting data for these indexes may be lacking scientific rigour they do reflect current trends in the industry. In general, it is empirically observable that websites providing rich experiences use JavaScript to do so. It stands to reason that an increasing number of developers are skilled with the language, and with the advent of server-side JavaScript frameworks, the language can be used universally for web applications, for both front- and back-end.

This paper sets out to analyze how an end-to-end JavaScript application compares to a more traditional design. It will briefly look at the steps taken to design an API for such an application, and then compare the two architectures. Section~\ref{sec:relwork} looks at related work. Section~\ref{sec:arch} provides details on the two architectures used for testing, especially the design. Section~\ref{sec:impl} provides details on the implementations, while section~\ref{sec:eval} evaluates them. Section~\ref{sec:fw} looks at possible avenues for improvement, while section~\ref{sec:con} concludes.

\section{\label{sec:relwork}Related Work}

\section{\label{sec:arch}Architecture}

To adequately compare an end-to-end JavaScript solution to a more traditional implementation, two versions of the same application must be built. In order for testing to be as meaningful as possible, the application will be kept minimal in terms of features, and will avoid certain kinds of complexity that will only add overhead in implementation, but provide little additional value for the stated goal of this experiment.

A post-and-comment type of system is a straightforward application to consider. Any number of posts can be created, and each post has any number of (flat) comments/replies as children. This model can be easily extended to a peer review site, message board or blogging platform, where the basic interaction is the same. User signup and authentication are not considered, as they only increases complexity without providing an interesting evaluation target --- neither are frequent operations.

\subsection{\label{sec:arch:API}API}

There are multiple approaches to building application programming interfaces for software, and often the chosen design depends on the type of API being built. For web applications, the Representational State Transfer~\cite{restful} (REST) model provides a straightforward approach to designing APIs, and fits well with the design of HTTP as it leverages existing HTTP verbs~\cite{rfc2616}. REST also fits well into the proposed application, as posts and comments neatly map to \emph{Resources}. Table~\ref{tab:api} lists the API. The combination of a HTTP verb and an URI immediately informs what the action will be --- this is one of the main benefits of using REST for API design.

\begin{table*}
    % \begin{tabular}{l p{1.15in} p{1.15in} p{1.15in} p{1in}}
    \begin{tabular}{*{5}l}
        \toprule
        \multicolumn{1}{c}{\textbf{URI}} & \multicolumn{4}{c}{\textbf{HTTP 1.1 Methods}} \\
        \cmidrule{2-5}
        & GET & PUT & POST & DELETE \\
        \midrule
        /posts/ & get posts & replace posts & create post & delete posts \\
        /post-\{id\}/ & get post & create/update post & update post & delete post \\
        /post-\{id\}/comments/ & get comms. & replace comms. & create comm. & delete comms. \\
        /post-\{id\}/comment-\{id\}/ & get comm. & create/update comm. & update comm. & delete comm. \\
        \bottomrule
    \end{tabular}
    \caption{API methods}
    \label{tab:api}
\end{table*}

\section{\label{sec:impl}Implementation}

Two server and two client applications were built for this experiment. One of the pairs is built entirely in JavaScript, using \textbf{node.js}~\cite{node} and \textbf{SproutCore}~\cite{sprout} for the server and client components, respectively. The other pair uses a Python back-end, powered by the \textbf{web.py}~\cite{webpy} framework, and a pure HTML front-end. Clients and servers use the API to communicate, and can be mixed in any server-client configuration desired. Table~\ref{tab:comps} lists all the components, their names and functions. Redis~\cite{redis} is used as the data store, as it provides a simple key-value interface that is more than sufficient for the given test scenario.

\begin{table}
    \begin{center}
        \begin{tabular}{l c c}
            \toprule
            & \textbf{JavaScript} & \textbf{Python/HTML} \\
            \midrule
            \textbf{Server} & Naka & Warusawa \\
            \textbf{Client} & Sh\={o}kaku & Hiry\={u}\\
            \bottomrule
        \end{tabular}
        \caption{Server and client components. The first character in each name serves as a mnemonic for the underlying technology, \emph{e.g.} \textbf{N}aka for \textbf{n}ode.js, \textbf{W}arusawa for \textbf{w}eb.py}
        \label{tab:comps}
    \end{center}
\end{table}

\subsection{\label{sec:impl:js}JavaScript}

\subsection{\label{sec:impl:pyhtml}Python \& HTML}

\subsection{\label{sec:impl:redis}Redis}

\section{\label{sec:eval}Evaluation}

\section{\label{sec:fw}Future Work}

\section{\label{sec:con}Conclusion}

% \begin{figure}[h!]
%     \centering
%         % actual name of file minus extension inside {}
%         \includegraphics[width=0.475\textwidth]{fig}
%     % caption - what's the fig about? move above \include if you prefer
%     \caption{A figure}
%     % labels make it nice to refer back to figures
%     \label{fig:figure1}
% \end{figure}
%
% A trick I sometimes use is to define figs in a separate file (say, \texttt{figures.sty}) and include it in the \texttt{usepackage} directive at the top of the document. Helpful when you have lots of pictures and want to make moving them around easier.
%
% Some embedded literal typeset code might look like the following :
%
% \texttt{
%     \small\lstinputlisting[language=Python]{code.py}
% }
%
% \subsubsection*{Suppressing Section Numbers}
%
% % \ldots for ellipsis, don't use three dots - poor spacing.
% You do so using \texttt{(sub\ldots)section*}

{\footnotesize
    \bibliographystyle{acm}
    \bibliography{bibliography}}

\end{document}







